
# 시간대별 캐싱 전략과 그 적용 이유

각 캐싱 전략이 특정 상황에 적합한 이유와 그 기술적 특징을 함께 설명드리겠습니다.

## 시간대 0 (0-10초, 20-30초): 주로 읽기 작업 중심

### 1. RefreshAhead (90% 확률)

**기술적 특징:**
- 예측 가능한 데이터를 미리 캐시에 로드
- 캐시 만료 전에 백그라운드에서 자동 갱신
- 사용자 요청 처리와 캐시 갱신이 분리됨

**왜 이 상황에 적합한가:**
- 오전 시간대 상품 조회 피크 시간에는 읽기 요청이 압도적으로 많음
- 인기 상품은 예측 가능하므로 미리 캐시 갱신 가능
- 사용자는 항상 캐시에서 데이터를 가져오므로 일관된 빠른 응답 시간 경험

**상황 예시:**
```
아침 9시에 많은 사용자가 인기 가전제품을 검색합니다. RefreshAhead 전략은 자정에 집계된 
인기 상품 목록을 미리 캐시하고, 백그라운드에서 주기적으로 (예: 5분마다) 최신 데이터로 갱신합니다.
사용자는 DB 접근 없이 항상 캐시에서 빠르게 데이터를 제공받으므로, 평균 응답 시간이 5ms 이하로 
유지되고 DB 부하가 70% 감소합니다.
```

### 2. WriteThrough (10% 확률)

**기술적 특징:**
- 캐시와 DB를 동시에 업데이트 (원자적 업데이트)
- 캐시와 DB 간 데이터 일관성 보장
- 쓰기 작업 지연 시간 증가 (DB 쓰기를 기다림)

**왜 이 상황에 적합한가:**
- 이 시간대에는 쓰기 작업이 적어 성능 영향 미미
- 간헐적 가격 변경 등 중요한 업데이트는 즉시 반영 필요
- 데이터 일관성이 속도보다 중요한 경우

**상황 예시:**
```
마케팅 담당자가 아침에 플래시 세일 가격을 설정합니다. WriteThrough 전략을 통해 가격 변경 정보가 
캐시와 DB에 동시에 업데이트되어, 모든 사용자가 정확한 가격 정보를 봅니다. 쓰기 작업이 전체 트래픽의 
10%에 불과하므로, DB 쓰기 대기 시간이 전체 시스템 성능에 큰 영향을 미치지 않습니다. 
이로 인해 가격 불일치로 인한 고객 불만이 98% 감소했습니다.
```

## 시간대 1 (10-20초): 읽기/쓰기 균형 상태

### 3. CacheAside (60% 확률)

**기술적 특징:**
- 애플리케이션이 캐시 관리를 직접 제어
- 캐시 미스 시에만 DB 접근
- 필요한 데이터만 캐시에 로드 (Lazy Loading)

**왜 이 상황에 적합한가:**
- 읽기/쓰기가 균형을 이루는 시간대에 유연하게 대응
- 다양한 상품 조회 패턴에 적응적
- 자주 사용되지 않는 데이터로 캐시가 오염되는 것 방지

**상황 예시:**
```
점심 시간에 다양한 카테고리의 상품이 조회됩니다. CacheAside 전략은 사용자가 조회한 상품만 
캐시에 저장하므로, 캐시 메모리를 효율적으로 사용합니다. 한 고객이 '무선 이어폰'을 검색하면, 
처음에는 DB에서 가져와 50ms가 소요되지만, 이후 다른 고객들의 동일 검색은 캐시에서 5ms 내에 
처리됩니다. 이 전략으로 제한된 캐시 용량에서도 90%의 히트율을 달성했습니다.
```

### 4. WriteBehind (40% 확률)

**기술적 특징:**
- 캐시 먼저 업데이트 후 비동기적으로 DB 업데이트
- 여러 쓰기 작업을 배치로 처리 가능
- 응답 시간 빠름 (DB 쓰기를 기다리지 않음)

**왜 이 상황에 적합한가:**
- 점심 시간대에 증가하는 주문 처리 속도 향상 필요
- 쓰기 작업의 비중이 높아지는 상황 (40%)
- 일시적 데이터 불일치를 허용할 수 있는 작업에 적합

**상황 예시:**
```
점심 시간에 많은 사용자가 장바구니에 상품을 추가합니다. WriteBehind 전략은 장바구니 변경을 
먼저 캐시에 반영하고 비동기적으로 DB에 기록합니다. 사용자는 추가 버튼 클릭 후 5ms 내에 응답을 
받고, 시스템은 100개의 장바구니 업데이트를 10초마다 일괄 처리하여 DB에 기록합니다. 
이로 인해 DB 쓰기 작업이 85% 감소하고, 사용자 경험이 크게 개선되었습니다.
```

## 시간대 2 (20-30초): 대량 쓰기 작업 중심

### 5. ReadThrough (40% 확률)

**기술적 특징:**
- 캐시가 DB 접근을 대신 처리
- 캐시 미스 시 자동으로 DB에서 로드
- 애플리케이션 로직에서 캐시 관리 코드 분리

**왜 이 상황에 적합한가:**
- 대량 쓰기 상황에서도 꾸준한 읽기 요청 처리 필요
- 개발자가 캐시 로직보다 비즈니스 로직에 집중할 수 있음
- 예측하기 어려운 새로운 인기 상품에 대한 요청 처리에 효과적

**상황 예시:**
```
할인 이벤트가 시작되면 갑자기 특정 상품의 인기가 높아집니다. ReadThrough 전략은 캐시에 없는 
새로운 인기 상품 정보를 자동으로 DB에서 가져와 캐시에 저장합니다. 예를 들어, 갑자기 SNS에서 
화제가 된 '스마트 조명'에 대한 조회가 급증했을 때, 첫 요청은 캐시 미스로 30ms가 소요되지만 
캐시 계층이 자동으로 이를 로드하여 이후 요청은 3ms 내에 처리됩니다. 이 자동화로 개발팀은 
캐시 관리 코드 작성 시간을 40% 절약했습니다.
```

### 6. WriteBehind (60% 확률)

**기술적 특징:**
- 대량의 쓰기 작업을 일괄 처리
- DB 연결 및 I/O 오버헤드 감소
- 쓰기 버퍼링으로 DB 부하 분산

**왜 이 상황에 적합한가:**
- 할인 이벤트 시 폭발적인 주문량 처리 필요
- DB 병목 현상 방지 중요
- 높은 쓰기 처리량이 최우선 요구사항

**상황 예시:**
```
특별 할인 시간에 수천 명의 고객이 동시에 주문합니다. WriteBehind 전략은 모든 주문을 
먼저 캐시에 기록하고, 100ms마다 최대 500개 주문을 배치로 DB에 기록합니다. 이 방식으로 
초당 5,000건의 주문 처리가 가능해지고, DB 연결 수가 95% 감소했습니다. 한 번의 플래시 세일에서 
시스템이 다운되지 않고 3분 내에 10만 건의 주문을 성공적으로 처리할 수 있었습니다.
```

## 각 전략 선택의 핵심 포인트

- **읽기 중심 시간대 (0, 2)**: 미리 준비(RefreshAhead)와 일관성(WriteThrough)이 중요
- **균형 시간대 (1)**: 유연성(CacheAside)과 응답성(WriteBehind)의 조합
- **쓰기 중심 시간대 (2)**: 자동화(ReadThrough)와 처리량(WriteBehind)에 초점

이처럼 시간대별, 트래픽 패턴별로 최적의 캐싱 전략을 조합함으로써 시스템은 다양한 상황에서 최고의 성능과 안정성을 발휘할 수 있습니다.
